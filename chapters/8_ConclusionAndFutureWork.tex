{\chapter{Conclusion and Future Work}
\label{chap:Conclusion}

In (\ref{chap:RelatedWork}), we presented an overview of other research that is related to our work in this thesis. In this chapter, we present some variables that we think they may pose threats to the validity of our research, we make a conclusion of the thesis as well as proposing points where our research can be extended in a future work. This chapter is consisted of the following sections:

\begin{itemize}  

\item \textbf{Threats to Validity:}\\
In section (\ref{sec:threatsToValidity}), we present a set of variables that we think may pose threats to the validity of our evaluation for the performance of the different graph structures.

\item \textbf{Conclusion:}\\
In section (\ref{sec:Conclusion}), we draw a conclusion of the work presented in this thesis.

\item \textbf{Future Work:}\\
In section (\ref{sec:futureWork}), we propose how future work can extend the work we have done in this thesis.

\end{itemize}

\section{Threats to Validity}
\label{sec:threatsToValidity}

In this thesis, we examined the influence of different variables (e.g. batch size and query type) on the performance of the different graph structures. In this section we present a set of variables that we believe may be a threat to the validity of our evaluation.


\begin{itemize}  

\item \textbf{Dataset:}\\
We used the randomly generated dataset \textit{LDBC} for benchmarking the graph data structures performance in loading and querying scenarios. We believe that the use of real life datasets that are different in size and schema may affect the performance of the graph data structures in loading and querying.

\item \textbf{Data Structure Optimization:}\\
We used the data structures offered in the \textit{Standard Template Library} (STL) of the $C++$ programming language as the building blocks for constructing the graph data structures. The $STL$ data structures are optimized for general purposes and not specifically optimized for the loading, storing, and retrieval of graph-like data. The lack of optimization for the data structures for the special nature of graph data may be a threat to the performance of the graph data structures that we built using them.


\end{itemize}

\section{Conclusion}
\label{sec:Conclusion}

The emergence in the use of specialized graph databases has imposed many challenges to the graph database designers in making their design choices. The graph structures utilized by graph databases for the storage and processing of graph data are contributing to the overall performance of the database, therefore choosing the proper graph structure that will best fits the user needs is of important weight. In this section, we conclude the main points we presented in this thesis on assessing the performance of graph structures.


\begin{itemize}  

\item \textbf{Graph Structures Scalability:}\\
The scalability of the three graph topology structures (adjacency matrix, compressed sparse row, and adjacency list) is contrasting. Adjacency matrix is the worst of the three in scalability specially from memory consumption point of view. Adjacency list takes the least time to load graph data, on the other hand compressed sparse row (CSR) makes the least memory footprint. Therefore, adjacency list is most recommended when loading time is crucial. On the other hand, CSR is the graph structure to use whenever a limitation in memory exists.

Due to its vertical partitioning based technique, the emerging schema method consumes the least memory among the three graph properties that we tested. However, universal table and nested key-value store are taking an almost equal loading time which is less than the loading time of emerging schema. Therefore, we recommend the emerging schema method in scenarios where memory saving has a higher weight than loading time. Both universal table or nested key-value store are more suitable for faster data loading than emerging schema.\\


\item \textbf{Loading Techniques:}\\
Changing the batch size in the batch loading strategy doesn't make a significant influence on the loading time of any of the graph structures. On the contrary, the parallel loading strategy improves the performance of data loading in both adjacency list and nested key-value store especially when the degree of parallelism is configured to match the maximum degree of parallelism offered by the processor.\\

\item \textbf{Query Performance:}\\
In regard to simple pattern-matching queries that require no traversals between the graph vertices, universal table shows the best query performance with least query response time. However, the combination of compressed sparse row (CSR) along with nested key-value store gives the best performance in executing complex pattern-matching queries that require traversals between the graph vertices.Lastly, adjacency list has small advantage ahead of CSR in regard to the performance of degree centrality queries.\\

\end{itemize}





\section{Future Work}
\label{sec:futureWork}

Despite our comprehensive evaluation of the major available graph data structures concerning their scalability, loading techniques, and query performance; their still exist points which we didn't cover and can be considered in future work. We summarize those points in the following list.

\begin{itemize}  

\item \textbf{Data Manipulation Workload:}\\
We have tested the performance of the graph structures in terms of the time taken in loading a graph data. The performance of graph structures in workloads that include manipulation of data by changing, deleting, or inserting values is a factor that influences the choice of a graph structure over another. Evaluating the performance of graph structures under a data manipulation workload need to be considered in a future work.

\item \textbf{Concurrency:}\\
A typical graph database will offer access to multiple user simultaneously. The concurrent access by users needs special handling by the database to schedule the operations of the users in a way that returns the expected result to the user and at the same time maintains the consistency of the database. Future work may consider the performance of the graph structures in performing concurrent operations requested by multiple users.

\item \textbf{Reachability, and Analytical Queries:}\\
In this thesis, we have examined the performance of the graph structures in the execution of two pattern-matching queries in addition to a degree centrality summarizing query. Other categories of queries haven't been covered in this thesis. Reachability queries are testing the possibility of reaching one vertex from another via a path of connected edges. Analytical queries are complex queries that performs statistical or analytical computation over the graph data. An example of an analytical query is the \textit{PageRank} algorithm \cite{Angles2018}. Also, the performance of the graph needs to be examined according to queries with varying selectivity parameters.

\end{itemize}


}
